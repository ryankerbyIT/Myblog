[
  
  {
    "title": "Building the Game of Domineering in Java: A Deep Dive into Object-Oriented Design",
    "url": "/posts/building-game-domineering-java/",
    "categories": "Projects, Algorithms",
    "tags": "Java, Java Games, Programming, Clean Code, Object-Oriented Programming, Data Structures, Algorithms",
    "date": "2024-09-26 23:00:00 -0500",
    





    
    "snippet": "Building Domineering in Java: A Comprehensive Guide to Game Logic, Data Structures, and OOPIntroductionDomineering is a two-player strategy game played on an 8x8 grid. Each player takes turns placi...",
    "content": "Building Domineering in Java: A Comprehensive Guide to Game Logic, Data Structures, and OOPIntroductionDomineering is a two-player strategy game played on an 8x8 grid. Each player takes turns placing dominoes on the board: one player places horizontally (east-west), while the other places vertically (north-south). The objective is to be the last player able to make a legal move. The game highlights critical concepts in programming, such as data structures, algorithms, and object-oriented design.This in-depth guide will take you through building Domineering in Java using an object-oriented approach. We’ll explore the logic behind the game, showcase how data structures like 2D arrays are employed, and discuss how various algorithms work together to simulate the game. Along the way, code examples will illustrate key aspects of the implementation.Overview of the Game  Players: Two players take turns placing dominoes. One places them horizontally, and the other places them vertically.  Objective: Be the last player able to make a legal move.  Gameplay: Players place dominoes (occupying two adjacent squares) onto an 8x8 grid. The game ends when one player cannot make a valid move.Setting Up the Game: The Domineering ClassThe entire game logic is encapsulated within a single class named Domineering. This class contains methods and attributes that handle the board’s state, manage player moves, and enforce the rules of the game.Code Walkthrough1. Defining the Board: Using a 2D Boolean ArrayA two-dimensional boolean array is used to represent the board. This array tracks the state of each square, determining whether it is occupied by a domino.// Array of board squares, true if occupied.private boolean[][] squares;// The board is initially empty.public Domineering() {    squares = new boolean[8][8];    // Java initializes all array elements to false.}Explanation:  squares Array: A boolean[][] array of size 8x8 is initialized to represent the board. Each element is false by default (Java initializes boolean arrays to false), indicating that the squares are unoccupied.  Space Complexity: The array has a fixed size of 64 elements, making it a memory-efficient way to represent the board.  Time Complexity: Accessing or modifying the elements of the array is an O(1) operation, allowing for quick checks and updates during gameplay.2. Rendering the Board: The toString MethodThe board’s current state is visualized using the toString method, which provides a string representation of the board.@Overridepublic String toString() {    StringBuilder result = new StringBuilder();    result.append(\"   1 2 3 4 5 6 7 8\"); // Column headers    for (int row = 0; row &lt; 8; row++) {        result.append(\"\\n\").append(row + 1).append(\" \"); // Row header (1-8)        for (int column = 0; column &lt; 8; column++) {            if (squares[row][column]) {                result.append(\" #\");            } else {                result.append(\" .\");            }        }    }    return result.toString();}Explanation  Column Headers: The first line adds numbers 1 through 8 to represent column numbers for easier input reference.  Row Headers: Each row in the grid is prefixed with its corresponding number (1 to 8).Occupied vs. Empty Squares: The method appends “ #” if a square is occupied (true), otherwise “ .”, creating a visual representation of the game state.  StringBuilder: Efficiently concatenates strings during board rendering, avoiding the performance penalty of repeated string concatenation.3. Managing Player Turns: The play MethodThe play method is the core game loop. It alternates turns between the horizontal and vertical players, checking for legal moves and handling player input.public void play() {    boolean player = HORIZONTAL;    while (true) {        System.out.println(\"\\n\" + this);        if (player == HORIZONTAL) {            System.out.println(\"Horizontal to play\");        } else {            System.out.println(\"Vertical to play\");        }        if (!hasLegalMoveFor(player)) {            System.out.println(\"No legal moves -- you lose!\");            return;        }        int row, column;        boolean validMove;        do {            System.out.print(\"Row (1-8): \");            row = INPUT.nextInt() - 1; // Adjust input to zero-indexed array            System.out.print(\"Column (1-8): \");            column = INPUT.nextInt() - 1; // Adjust input to zero-indexed array            validMove = isValidMove(row, column, player);            if (!validMove) {                System.out.println(\"Invalid move! Try again.\");            }        } while (!validMove);        playAt(row, column, player);        player = !player;    }}Explanation  Main Game Loop: Continuously runs, alternating between the horizontal and vertical players until one cannot make a legal move.  Turn Indication: Displays which player’s turn it is, enhancing user interaction.  Input Handling: Prompts the player to input the row and column, adjusting the 1-based input to the 0-based indexing used by the array (row - 1 and column - 1).  Move Validation: Calls isValidMove() to check if the move is legal. If not, it prompts the user to try again.  Play Execution: Calls playAt() to place the domino on the board.  Switch Player: Toggles the player variable to alternate turns.Validating Moves: The isValidMove MethodThis method checks whether the proposed move is valid for the current player.public boolean isValidMove(int row, int column, boolean player) {    int rowOffset = player == VERTICAL ? 1 : 0;    int columnOffset = player == HORIZONTAL ? 1 : 0;    // Check if move is within bounds    if (row &lt; 0 || row + rowOffset &gt;= 8 || column &lt; 0 || column + columnOffset &gt;= 8) {        return false;    }    // Check if both squares are unoccupied    return !squares[row][column] &amp;&amp; !squares[row + rowOffset][column + columnOffset];}Explanation  Bounds Check: Ensures that the domino does not exceed the board’s boundaries.  Occupied Check: Checks that both squares required for the domino placement are unoccupied.  Offsets: Uses rowOffset and columnOffset to differentiate between horizontal and vertical placements, ensuring the method can validate moves for both players.  Efficiency: Runs in constant time (O(1)) because it only performs a few checks.5. Placing Dominoes: The playAt MethodThe playAt method updates the board to reflect the placement of the domino.public void playAt(int row, int column, boolean player) {    if (player == HORIZONTAL) {        squares[row][column] = true;        squares[row][column + 1] = true;    } else {        squares[row][column] = true;        squares[row + 1][column] = true;    }}Explanation  Horizontal Placement: Marks the current square and the square to the right as occupied.  Vertical Placement: Marks the current square and the square below as occupied.  Assumption: This method assumes that isValidMove() has already confirmed the legality of the move.6. Checking for Legal Moves: The hasLegalMoveFor MethodThis method checks if there are any legal moves left for the current player.public boolean hasLegalMoveFor(boolean player) {    int rowOffset = player == VERTICAL ? 1 : 0;    int columnOffset = player == HORIZONTAL ? 1 : 0;    for (int row = 0; row &lt; (8 - rowOffset); row++) {        for (int column = 0; column &lt; (8 - columnOffset); column++) {            if (!squares[row][column] &amp;&amp; !squares[row + rowOffset][column + columnOffset]) {                return true;            }        }    }    return false;}Explanation  Search for Legal Moves: Iterates over each square on the board to find at least one valid move for the specified player.  Adjusts for Orientation: Uses rowOffset and columnOffset to check the availability of spaces required for horizontal or vertical placements.  Complexity: Runs in O(n^2) time for an n x n board. However, since the board size is fixed (8x8), this operation is effectively O(1) in practical terms.Key Object-Oriented Concepts in Use1. EncapsulationEncapsulation is the concept of bundling data (attributes) and methods that operate on the data into a single unit, or class, while hiding the internal state from outside interference. In this implementation:  The board state is encapsulated within the Domineering class using a private 2D boolean array (squares). Direct access to this array is restricted, allowing it to be manipulated only through the class’s methods (e.g., playAt(), isValidMove()).  Methods like isValidMove(), playAt(), and hasLegalMoveFor() interact with the board’s state, ensuring that only valid operations are performed on the board. This encapsulation enforces game rules and prevents unauthorized changes to the board’s internal state.Code Example: Encapsulationprivate boolean[][] squares; // Encapsulated board statepublic void playAt(int row, int column, boolean player) {    if (player == HORIZONTAL) {        squares[row][column] = true;        squares[row][column + 1] = true;    } else {        squares[row][column] = true;        squares[row + 1][column] = true;    }}  The squares array is marked as private, hiding it from external access.  The playAt() method modifies the squares array internally while ensuring that only valid placements (based on previous validation) are made.2. AbstractionAbstraction is about simplifying complex reality by modeling classes that represent real-world objects and concepts while exposing only the essential details. In this implementation:  The Domineering class abstracts the concept of the Domineering game, handling board management, player moves, and game rules.  The internal workings of move validation and placement are hidden from the user, allowing them to interact with the game at a higher level (e.g., inputting row and column numbers).Code Example: Abstractionpublic boolean isValidMove(int row, int column, boolean player) {    int rowOffset = player == VERTICAL ? 1 : 0;    int columnOffset = player == HORIZONTAL ? 1 : 0;    // Check if move is within bounds    if (row &lt; 0 || row + rowOffset &gt;= 8 || column &lt; 0 || column + columnOffset &gt;= 8) {        return false;    }    // Check if both squares are unoccupied    return !squares[row][column] &amp;&amp; !squares[row + rowOffset][column + columnOffset];}The isValidMove() method abstracts the complex logic needed to determine if a move is valid, encapsulating it within a simple, easy-to-use method. Users of this method don’t need to know the underlying mechanics; they just get a true or false result indicating move validity.3. Inheritance (N/A in this Example)The current implementation does not use inheritance directly, as there is no subclassing or hierarchy involved. However, this design could be extended in the future with additional classes to represent different board types or game variations.4. Polymorphism (N/A in this Example)While the game does not employ polymorphism directly, there is potential for its use. For instance, if you decide to implement computer-controlled players or different game variations, you could use polymorphism to define a common interface for different player types (human, AI) or board configurations.5. Single Responsibility Principle (SRP)The class design follows the Single Responsibility Principle, a core principle of object-oriented design. The Domineering class is solely responsible for managing the game state, player interactions, and enforcing game rules. Each method within the class has a distinct responsibility:  toString(): Handles board rendering.  play(): Manages the gameplay loop and player turns.  isValidMove(): Checks if a player’s move is valid.  playAt(): Updates the board state for a valid move.  hasLegalMoveFor(): Checks for any remaining legal moves for the current player.Enhancing the Game: Possible Extensions1. Adding an AI PlayerOne possible enhancement is to implement an AI opponent. This would involve creating a new class (e.g., AIPlayer) that contains methods for decision-making based on board analysis. This class would interact with the Domineering class through public methods like isValidMove() and playAt(), illustrating further use of encapsulation and abstraction.2. Creating a Graphical InterfaceWhile the current implementation is console-based, adding a graphical interface (using JavaFX or Swing) could improve the game’s interactivity. In this scenario, the Domineering class would serve as the “model” in a Model-View-Controller (MVC) design pattern, where the graphical interface would represent the “view” and “controller” components.3. Implementing Inheritance for Board VariationsSuppose you want to support different board sizes or types. In that case, you could create a base class (e.g., Board) and derive specific classes (StandardBoard, LargeBoard) from it, using inheritance to handle variations in board behavior.ConclusionThis implementation of Domineering in Java offers a rich learning experience in object-oriented design, data structures, and algorithms:  Object-Oriented Design: By encapsulating the game’s data and logic within the Domineering class, the code is modular, extensible, and easy to understand.  Data Structures: A simple 2D boolean array serves as the board, demonstrating how a straightforward data structure can effectively model complex game mechanics.  Algorithms: The methods for move validation, placement, and game state evaluation encapsulate the game’s core logic, showcasing the use of efficient algorithms to drive gameplay.By understanding and implementing these concepts, one can appreciate the power of object-oriented programming in building interactive applications. This game can serve as a foundation for more complex projects, from board game simulators to AI-driven strategy games."
  },
  
  {
    "title": "Building Bug Builder: A Step-by-Step Guide to Developing a Java Game",
    "url": "/posts/java-bugbuilder-game-challenge/",
    "categories": "Projects, Algorithms",
    "tags": "Java, Java Games, Programming, Clean Code, Object-Oriented Programming",
    "date": "2024-09-25 23:00:00 -0500",
    





    
    "snippet": "Building “Bug Builder” in Java: An Iterative ApproachIntroduction“Bug Builder” is a simple, yet strategic game that involves players rolling dice to build a virtual bug. The game’s objective is to ...",
    "content": "Building “Bug Builder” in Java: An Iterative ApproachIntroduction“Bug Builder” is a simple, yet strategic game that involves players rolling dice to build a virtual bug. The game’s objective is to complete the bug by collecting all the necessary parts—body, head, legs, eyes, antennae, and stinger—through dice rolls. Although the game’s mechanics are straightforward, developing a software version of the game in Java offers several challenges and opportunities for strategic design and implementation.This guide provides a step-by-step approach to building “Bug Builder” in Java, starting with the bare minimum and iterating through to a fully functional game. The development will begin by identifying the necessary classes and their attributes, implementing a basic version of the game, and then expanding its features. The guide emphasizes testing and debugging at each stage, ensuring the program functions correctly as it evolves.Planning and Initial DesignBefore diving into coding, a thorough analysis of the game’s mechanics and requirements is crucial. “Bug Builder” has a simple objective: to be the first player to complete their bug. However, implementing this in a Java program requires careful planning of classes, data structures, and game logic.Game AnalysisThe game consists of rolling a die to determine which parts of the bug can be added during each turn. Each player starts with an incomplete bug, and the addition of parts is governed by specific rules:  A player can only add the body if it hasn’t already been added.  The head can only be added if the body exists.  Legs, eyes, antennae, and the stinger have similar conditions based on existing parts.  The game continues in rounds until a player completes their bug.From this, we can identify the primary components of the game:  Bug Parts: Body, head, legs, eyes, antennae, and stinger.  Game Mechanics: Turn-based gameplay with dice rolls.  Players: Each player controls their own bug and takes turns rolling the die.Class IdentificationWith the game mechanics broken down, the next step is to identify the classes and their roles in the program:  Bug Class: Represents the bug that each player is trying to build. It will have attributes to track which parts are present.  Player Class: Represents each player in the game. It will contain a reference to their Bug object and handle interactions during their turn.  Die Class: Represents a six-sided die and includes a method to simulate rolling it.  Game Class: Manages the game loop, player turns, and the overall state of the game.Attributes and MethodsNext, we outline the attributes and methods each class will need:  Bug Class:          Attributes: Boolean variables for hasBody, hasHead, legsCount, eyesCount, antennaeCount, and hasStinger.      Methods: addBody(), addHead(), addLegs(), addEye(), addAntennae(), addStinger(), and getBugStatus() to check the current state of the bug.        Player Class:          Attributes: name (String), bug (Bug object).      Methods: rollDie() to simulate a die roll, takeTurn() to perform actions based on the roll.        Die Class:          Attributes: None required.      Methods: roll() to return a random integer between 1 and 6.        Game Class:          Attributes: List of Player objects, currentPlayerIndex.      Methods: startGame(), playTurn(), checkGameOver(), and displayWinner().      Step 1: Building the Core SkeletonTo create a robust and scalable program, we start by implementing the minimum viable product (MVP) for the “Bug Builder” game. The MVP should focus on building the essential Bug class and setting up the basic game loop. This core skeleton will serve as the foundation on which we will iteratively build the remaining features.First Iteration - The Bug ClassThe primary object in our game is the “bug” that players will build. In this first iteration, we will create a simple Bug class that allows a player to add a body to their bug.public class Bug {    private boolean hasBody;    public Bug() {        this.hasBody = false;    }    public void addBody() {        if (!hasBody) {            hasBody = true;            System.out.println(\"The body has been added to the bug.\");        } else {            System.out.println(\"The bug already has a body.\");        }    }    public void displayStatus() {        System.out.println(\"Bug Status: \" + (hasBody ? \"Body present\" : \"Body missing\"));    }}Step 2: Adding Game MechanicsWith the basic Bug class and game loop in place, it’s time to expand the game mechanics. We’ll implement additional bug parts, dice rolls, and introduce the Player and Game classes.Expanding the Bug ClassThe updated Bug class will handle all parts (body, head, legs, eyes, antennae, and stinger) using boolean variables and counters.public class Bug {    private boolean hasBody;    private boolean hasHead;    private int legsCount;    private int eyesCount;    private int antennaeCount;    private boolean hasStinger;    private final int MAX_LEGS = 6;    private final int MAX_EYES = 2;    private final int MAX_ANTENNAE = 2;    public Bug() {        this.hasBody = false;        this.hasHead = false;        this.legsCount = 0;        this.eyesCount = 0;        this.antennaeCount = 0;        this.hasStinger = false;    }    public void addBody() {        if (!hasBody) {            hasBody = true;            System.out.println(\"The body has been added to the bug.\");        } else {            System.out.println(\"The bug already has a body.\");        }    }    public void addHead() {        if (hasBody &amp;&amp; !hasHead) {            hasHead = true;            System.out.println(\"The head has been added to the bug.\");        } else if (!hasBody) {            System.out.println(\"Cannot add the head without the body.\");        } else {            System.out.println(\"The bug already has a head.\");        }    }    public void addLegs() {        if (hasBody &amp;&amp; legsCount &lt; MAX_LEGS) {            legsCount += 2;            System.out.println(\"Two legs have been added. Total legs: \" + legsCount);        } else if (!hasBody) {            System.out.println(\"Cannot add legs without the body.\");        } else {            System.out.println(\"The bug already has the maximum number of legs.\");        }    }    public void addEye() {        if (hasHead &amp;&amp; eyesCount &lt; MAX_EYES) {            eyesCount++;            System.out.println(\"An eye has been added. Total eyes: \" + eyesCount);        } else if (!hasHead) {            System.out.println(\"Cannot add eyes without the head.\");        } else {            System.out.println(\"The bug already has two eyes.\");        }    }    public void addAntennae() {        if (hasHead &amp;&amp; antennaeCount &lt; MAX_ANTENNAE) {            antennaeCount++;            System.out.println(\"An antenna has been added. Total antennae: \" + antennaeCount);        } else if (!hasHead) {            System.out.println(\"Cannot add antennae without the head.\");        } else {            System.out.println(\"The bug already has two antennae.\");        }    }    public void addStinger() {        if (hasBody &amp;&amp; !hasStinger) {            hasStinger = true;            System.out.println(\"The stinger has been added to the bug.\");        } else if (!hasBody) {            System.out.println(\"Cannot add the stinger without the body.\");        } else {            System.out.println(\"The bug already has a stinger.\");        }    }    public boolean isComplete() {        return hasBody &amp;&amp; hasHead &amp;&amp; legsCount == MAX_LEGS &amp;&amp; eyesCount == MAX_EYES &amp;&amp; antennaeCount == MAX_ANTENNAE &amp;&amp; hasStinger;    }    public void displayStatus() {        System.out.println(\"Bug Status:\");        System.out.println(\"  Body: \" + (hasBody ? \"Present\" : \"Missing\"));        System.out.println(\"  Head: \" + (hasHead ? \"Present\" : \"Missing\"));        System.out.println(\"  Legs: \" + legsCount + \"/\" + MAX_LEGS);        System.out.println(\"  Eyes: \" + eyesCount + \"/\" + MAX_EYES);        System.out.println(\"  Antennae: \" + antennaeCount + \"/\" + MAX_ANTENNAE);        System.out.println(\"  Stinger: \" + (hasStinger ? \"Present\" : \"Missing\"));    }}Implementing the Player and Die ClassesThe Player class manages player interactions during their turns, and the Die class simulates rolling a six-sided die.import java.util.Random;public class Die {    private Random random;    public Die() {        this.random = new Random();    }    public int roll() {        return random.nextInt(6) + 1;    }}public class Player {    private String name;    private Bug bug;    private Die die;    public Player(String name) {        this.name = name;        this.bug = new Bug();        this.die = new Die();    }    public void takeTurn() {        int roll = die.roll();        System.out.println(name + \" rolled a \" + roll + \".\");        switch (roll) {            case 1:                bug.addBody();                break;            case 2:                bug.addHead();                break;            case 3:                bug.addLegs();                break;            case 4:                bug.addEye();                break;            case 5:                bug.addAntennae();                break;            case 6:                bug.addStinger();                break;            default:                System.out.println(\"Invalid roll.\");                break;        }        bug.displayStatus();    }    public boolean hasCompleteBug() {        return bug.isComplete();    }    public String getName() {        return name;    }    public Bug getBug() {        return bug;    }}TestingWith the Bug and Player classes in place, we now introduce the Game class to manage gameplay for multiple players.Implementing the Game ClassThe Game class is responsible for managing the game loop, tracking player turns, and checking for game completion.import java.util.ArrayList;import java.util.List;import java.util.Scanner;public class Game {    private List&lt;Player&gt; players;    private int currentPlayerIndex;    private Scanner scanner;    public Game() {        players = new ArrayList&lt;&gt;();        currentPlayerIndex = 0;        scanner = new Scanner(System.in);    }    public void startGame() {        System.out.println(\"Welcome to Bug Builder!\");        int numPlayers = 0;        while (numPlayers &lt;= 0) {            try {                System.out.print(\"Enter the number of players: \");                numPlayers = Integer.parseInt(scanner.nextLine());                if (numPlayers &lt;= 0) {                    System.out.println(\"Number of players must be greater than zero.\");                }            } catch (NumberFormatException e) {                System.out.println(\"Invalid input. Please enter a valid number.\");            }        }        for (int i = 1; i &lt;= numPlayers; i++) {            System.out.print(\"Enter name for Player \" + i + \": \");            String name = scanner.nextLine();            players.add(new Player(name));        }        System.out.println(\"Let's start the game! Press Enter to roll the die.\");        while (!checkGameOver()) {            playTurn();            currentPlayerIndex = (currentPlayerIndex + 1) % players.size();        }        displayWinner();    }    private void playTurn() {        Player currentPlayer = players.get(currentPlayerIndex);        System.out.println(currentPlayer.getName() + \"'s turn. Press Enter to roll the die.\");        scanner.nextLine();        currentPlayer.takeTurn();        currentPlayer.getBug().displayStatus();    }    private boolean checkGameOver() {        for (Player player : players) {            if (player.hasCompleteBug()) {                return true;            }        }        return false;    }    private void displayWinner() {        for (Player player : players) {            if (player.hasCompleteBug()) {                System.out.println(player.getName() + \" has completed their bug! Congratulations!\");                break;            }        }        System.out.println(\"Game over!\");    }}You can call this restartGame() method at the end of the displayWinner() method to prompt players for a replay. This allows for continuous gameplay without restarting the program.Step 4: Additional Features to ConsiderIf you would like to add more depth to the game, consider implementing these potential enhancements:      Score Tracking: Implement a scoring system that tracks how many turns each player takes to complete their bug. For example, keep a counter for each player and display the total number of turns taken at the end of the game. This would allow for competitive multi-round gameplay, where the player with the fewest total turns wins.     private int turnCount; public void takeTurn() {     turnCount++;     // existing turn logic... } public int getTurnCount() {     return turnCount; }        You can then display the score in the displayWinner() method.        Graphical User Interface (GUI): Convert this console-based game into a graphical application using JavaFX or Swing. A GUI would enhance the user experience by adding visual representations of the bug and dice rolls, providing a more interactive and engaging interface.        AI Opponents: Implement AI-controlled players that simulate human actions during gameplay. For example, an AI player could use simple logic to decide on its next move. This would allow for solo play against computer-generated opponents.        Save and Load Game: Add functionality to save the current game state to a file and reload it later. This would involve serializing the Game, Player, and Bug objects to store their states and deserializing them when loading the game.     public void saveGame() {     try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\"savegame.dat\"))) {         out.writeObject(this);         System.out.println(\"Game saved successfully.\");     } catch (IOException e) {         System.out.println(\"Error saving the game.\");     } } public static Game loadGame() {     try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(\"savegame.dat\"))) {         return (Game) in.readObject();     } catch (IOException | ClassNotFoundException e) {         System.out.println(\"Error loading the game.\");         return null;     } }      ConclusionBy following an iterative development process, we have successfully built the “Bug Builder” game in Java, starting with a minimal implementation and gradually adding complexity. We covered the basic game mechanics, handling player interactions, and managing the turn-based system using object-oriented programming principles.Through careful planning and iterative refinement, the game now supports multiple players, interactive feedback, and the flexibility to add future enhancements. Further work could involve adding more sophisticated features like a graphical user interface, AI players, or a scoring system to deepen gameplay.The “Bug Builder” project is an excellent example of how to take a simple concept and develop it into a full-featured program using Java. With a solid foundation now in place, you have the tools and structure needed to extend this game even further, whether through adding new gameplay elements or enhancing the user experience. Happy coding!"
  },
  
  {
    "title": "Introduction to Encapsulation",
    "url": "/posts/data-structures-and-algorithms-encapsulation/",
    "categories": "Blogging, Software Engineering",
    "tags": "Encapsulation, Programming, Data Structures And Algorithms",
    "date": "2024-09-25 23:00:00 -0500",
    





    
    "snippet": "Introduction to EncapsulationDefinition of Encapsulation in Object-Oriented Programming (OOP)Encapsulation is one of the four fundamental principles of object-oriented programming (OOP), alongside ...",
    "content": "Introduction to EncapsulationDefinition of Encapsulation in Object-Oriented Programming (OOP)Encapsulation is one of the four fundamental principles of object-oriented programming (OOP), alongside inheritance, polymorphism, and abstraction. In its simplest form, encapsulation refers to the bundling of data and methods that operate on that data within a single unit, usually called a class in programming languages like Java, Python, and C#. The concept is inspired by the real world, where objects are self-contained entities with their own characteristics and behaviors. In programming, encapsulation allows data (fields, variables) and methods (functions) to be bundled together, restricting direct access to the data and allowing manipulation only through defined interfaces or methods.Encapsulation is often described as “data hiding” because it enables programmers to hide the internal state of an object from the outside world. Only the object’s own methods can access and modify its internal state, which enforces a controlled way of interacting with the object’s data. This restriction is primarily implemented through the use of access modifiers in programming languages. For example, in Java and C#, the private keyword restricts access to fields and methods, while public grants access. By controlling which parts of an object can be accessed or modified, encapsulation creates a clear boundary that separates an object’s internal mechanics from its external interface.To break this down further, encapsulation can be divided into two main components: data encapsulation and method encapsulation. Data encapsulation involves protecting the internal state of an object by defining private fields. Access to these fields is typically provided through public methods known as “getters” and “setters.” These methods allow for controlled access, often implementing validation or other processing before updating the object’s state. Method encapsulation, on the other hand, involves creating private methods within a class that are not accessible from outside the class. These methods perform internal tasks that support the object’s public interface but are not part of the functionality intended for the outside world.Encapsulation is critical in software development for several reasons:      Data Integrity: By restricting direct access to an object’s fields, encapsulation ensures that the internal state of the object cannot be corrupted by external interference. For example, if a class represents a bank account, encapsulating its balance field prevents unauthorized or erroneous modifications. Accessing or modifying the balance is only possible through methods like deposit() or withdraw(), which can include validation logic, such as checking for sufficient funds.        Code Maintainability: Encapsulation encourages modular code. When an object’s data and behaviors are bundled together, it becomes easier to locate, understand, and modify that part of the codebase. If changes need to be made to the internal workings of a class, they can be made in isolation without affecting other parts of the program, as long as the public interface remains consistent.        Reusability: Well-encapsulated classes are reusable components. A class that encapsulates its data and provides a clear interface can be used in multiple programs or projects without requiring changes to its internal code. For instance, a class that models a stack data structure with encapsulated push, pop, and peek methods can be used in different applications, whether they involve processing web pages, managing a call stack in a programming language interpreter, or maintaining a history of user actions in a software application.        Abstraction and Simplicity: Encapsulation complements the concept of abstraction by allowing developers to define a simplified interface for complex data structures and algorithms. Users of an encapsulated class do not need to understand its internal implementation; they only need to know how to interact with its public methods. For example, a sorting algorithm encapsulated within a class might provide a simple sort() method, while the internal workings (e.g., bubble sort, merge sort, or quicksort) remain hidden and can be changed as needed without affecting code that relies on the sorting class.  Example: Encapsulation in a Bank Account ClassTo illustrate encapsulation in practice, consider a class that models a simple bank account:```javapublic class BankAccount {    private double balance; // Encapsulated field// Constructorpublic BankAccount(double initialBalance) {    this.balance = initialBalance;}// Public method to get the balancepublic double getBalance() {    return balance;}// Public method to deposit moneypublic void deposit(double amount) {    if (amount &gt; 0) {        balance += amount;    }}// Public method to withdraw moneypublic void withdraw(double amount) {    if (amount &gt; 0 &amp;&amp; amount &lt;= balance) {        balance -= amount;    }} } #### **Why Encapsulation Matters in Data Structures and Algorithms**When designing data structures and algorithms, encapsulation plays a crucial role in managing complexity. Data structures, such as arrays, linked lists, stacks, queues, and trees, often have intricate internal details that define their behavior. For example, a binary search tree requires a careful arrangement of nodes to maintain its properties, allowing efficient searching, insertion, and deletion of elements. Encapsulating the internal nodes and operations of the tree ensures that external code cannot inadvertently violate these properties, which would compromise the integrity of the data structure.Moreover, algorithms that operate on data structures frequently involve complex operations that need to be encapsulated. A sorting algorithm might include various internal procedures, such as partitioning an array, merging subarrays, or swapping elements. Encapsulation allows these internal procedures to be implemented as private methods within a class, simplifying the external interface and making the algorithm easier to use and maintain.Encapsulation is equally valuable when dealing with advanced data structures like graphs and hash tables. For instance, a graph data structure might encapsulate its nodes and edges in a way that ensures the graph’s consistency. Public methods for adding and removing nodes and edges enforce rules that prevent the creation of invalid graph states, such as self-loops or disconnected components (if the graph is meant to be connected). This encapsulated approach allows users to interact with the graph at a high level without needing to manage its low-level details.Similarly, encapsulating the inner workings of a hash table, such as its array of buckets and hashing function, ensures that external code cannot interfere with its internal collision-handling mechanisms. The public methods of the hash table (e.g., put(), get(), remove()) provide a controlled interface for interacting with the data structure while hiding its complexity.Encapsulation not only safeguards data structures and algorithms but also encourages the development of flexible and reusable components. By adhering to encapsulation principles, developers can design classes that are easy to modify, test, and extend. Encapsulation also sets the stage for applying other OOP principles, such as inheritance and polymorphism, which further enhance the design of data structures and algorithms.References  Larman, C. (2002). Applying UML and Patterns: An Introduction to Object-Oriented Analysis and Design and Iterative Development. Prentice Hall.  Bloch, J. (2017). Effective Java. Addison-Wesley.  Gamma, E., Helm, R., Johnson, R., &amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley.  Eckel, B. (2006). Thinking in Java. Prentice Hall.  Cormen, T. H., Leiserson, C. E., Rivest, R. L., &amp; Stein, C. (2009). Introduction to Algorithms. MIT Press."
  },
  
  {
    "title": "The Role of Culture in Shaping Enterprise Architecture",
    "url": "/posts/enterprise-architecture-culture/",
    "categories": "Blogging, Enterprise Architecture",
    "tags": "EA, Organizational Culture, Business Strategy",
    "date": "2024-09-25 23:00:00 -0500",
    





    
    "snippet": "IntroductionEnterprise Architecture (EA) is a framework that aligns an organization’s IT infrastructure with its business goals. While EA provides a clear structure for optimizing resources, mitiga...",
    "content": "IntroductionEnterprise Architecture (EA) is a framework that aligns an organization’s IT infrastructure with its business goals. While EA provides a clear structure for optimizing resources, mitigating risks, and identifying innovation opportunities, it does not operate in a vacuum. Organizational culture, which encompasses the values, beliefs, and behaviors shared among employees, significantly shapes the success of EA initiatives.EA initiatives require buy-in from leadership, cross-departmental collaboration, and a willingness to embrace change. This post explores how culture influences EA’s development, implementation, and sustainability, with real-world examples from companies like Toyota, Netflix, Amazon, Kodak, and Blockbuster. It also addresses how global organizations adapt EA to diverse regional cultures and how leadership can foster a culture that supports architectural innovation.Understanding Organizational Culture and EAOrganizational Culture: A Brief OverviewOrganizational culture defines the shared values, norms, and practices that influence employee behavior and decision-making within a company. A strong culture of collaboration and innovation can significantly impact how receptive an organization is to technological change, directly affecting EA success.EA, which serves as a blueprint aligning business strategies with IT systems, thrives in cultures that support integration and new processes. Companies like Amazon, which prioritize customer satisfaction, use EA to develop technologies that support their cultural values.Enterprise Architecture and Cultural AlignmentEA comprises four primary pillars: business, information, applications, and technology. These pillars must align with the company’s culture to deliver maximum value. For instance, companies with siloed cultures may struggle to leverage EA fully due to poor cross-departmental communication and collaboration.The Influence of Leadership Culture on EA SuccessToyota: The Power of KaizenLeadership culture plays a pivotal role in EA initiatives. At Toyota, the concept of Kaizen—continuous improvement—permeates the organization, encouraging employees to enhance operations consistently. This cultural foundation aligns seamlessly with EA principles, focusing on long-term value and process optimization. Toyota’s collaborative leadership ensures that EA is integrated into operations as a natural extension of their practices.Yahoo: Misaligned Leadership CultureConversely, misaligned leadership can lead to EA failure. During Marissa Mayer’s tenure at Yahoo, her push for aggressive deadlines clashed with Yahoo’s broader culture, which emphasized employee satisfaction and creativity. This misalignment resulted in poorly executed EA initiatives, contributing to the company’s decline.Employee Resistance and Change ManagementKodak: A Culture Resistant to ChangeOne of the biggest challenges in implementing EA is employee resistance, often rooted in a culture not aligned with evolving technology. Kodak serves as a cautionary tale; despite pioneering digital photography, its film-centric culture resisted the shift to digital. This reluctance to embrace change prevented Kodak from aligning its EA with the future of digital imaging, ultimately leading to its decline.Netflix: A Culture of InnovationNetflix, on the other hand, exemplifies how a culture of innovation supports EA implementation. Netflix transitioned from a DVD rental service to streaming, requiring a complete overhaul of its IT infrastructure. Its culture of experimentation and risk-taking allowed for quick adaptation to new technologies, resulting in a dominant market position.Global and Regional Cultural Impacts on EAIBM: Adapting EA to Regional CulturesGlobal companies must navigate diverse regional cultures when implementing EA. IBM, a global IT leader, adapted its EA practices to align with varying cultural contexts. In regions like Japan, known for their risk-averse nature, IBM developed a flexible EA framework that could be customized to fit the local culture. This approach allowed IBM to successfully implement EA worldwide while respecting regional differences in decision-making and collaboration.Case Study: Amazon’s Culture of Customer ObsessionAmazon’s culture of customer obsession drives every aspect of its business, influencing its EA strategy. This approach has led to the development of an agile, scalable EA framework that supports rapid innovation. A prime example is Amazon Web Services (AWS), which underpins the company’s operations and serves thousands of other businesses.However, Amazon’s rapid growth and global expansion come with cultural challenges. Managing diverse regional teams requires Amazon to tailor its EA implementation according to varying labor regulations and consumer expectations, demonstrating how culture influences EA on a global scale.ConclusionCulture plays a critical role in the success or failure of EA initiatives. Organizations that foster collaboration, continuous improvement, and innovation, like Toyota and Netflix, are more likely to implement EA successfully. Conversely, companies resistant to change, such as Kodak, may struggle to align their IT infrastructure with evolving business goals.Leadership is crucial in shaping a culture that supports EA, as seen in the contrasting cases of Amazon and Yahoo. For global companies like IBM and Amazon, navigating regional cultural differences is essential when implementing EA.To unlock the full potential of EA, organizations must cultivate a culture that embraces change, encourages collaboration, and aligns with long-term business and IT strategies.References  Hastings, R. &amp; Meyer, E. (2020). No Rules Rules: Netflix and the Culture of Reinvention. Penguin Press.  Liker, J. K. (2004). The Toyota Way: 14 Management Principles from the World’s Greatest Manufacturer. McGraw-Hill Education.  Lucas, H. C. &amp; Goh, J. M. (2009). “Disruptive technology: How Kodak missed the digital photography revolution.” The Journal of Strategic Information Systems, 18(1), 46-55.  MacCormack, A., Baldwin, C. Y., &amp; Rusnak, J. (2012). The Architecture of Complex Systems: Managing Design and Execution. Harvard Business School.  Mattioli, D. (2020). Amazon Unbound: Jeff Bezos and the Invention of a Global Empire. Simon &amp; Schuster.  McCord, P. (2014). “How Netflix Reinvented HR.” Harvard Business Review."
  },
  
  {
    "title": "Welcome to Jekyll!",
    "url": "/posts/welcome-to-jekyll/",
    "categories": "jekyll, update",
    "tags": "",
    "date": "2024-09-24 22:41:09 -0500",
    





    
    "snippet": "You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run je...",
    "content": "You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.Jekyll requires blog post files to be named according to the following format:YEAR-MONTH-DAY-title.MARKUPWhere YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and MARKUP is the file extension representing the format used in the file. After that, include the necessary front matter. Take a look at the source for this post to get an idea about how it works.Jekyll also offers powerful support for code snippets:def print_hi(name)  puts \"Hi, #{name}\"endprint_hi('Tom')#=&gt; prints 'Hi, Tom' to STDOUT.Check out the Jekyll docs for more info on how to get the most out of Jekyll. File all bugs/feature requests at Jekyll’s GitHub repo. If you have questions, you can ask them on Jekyll Talk."
  },
  
  {
    "title": "Customize the Favicon",
    "url": "/posts/customize-the-favicon/",
    "categories": "Blogging, Tutorial",
    "tags": "favicon",
    "date": "2019-08-10 11:34:00 -0500",
    





    
    "snippet": "The favicons of Chirpy are placed in the directory assets/img/favicons/. You may want to replace them with your own. The following sections will guide you to create and replace the default favicons...",
    "content": "The favicons of Chirpy are placed in the directory assets/img/favicons/. You may want to replace them with your own. The following sections will guide you to create and replace the default favicons.Generate the faviconPrepare a square image (PNG, JPG, or SVG) with a size of 512x512 or more, and then go to the online tool Real Favicon Generator and click the button Select your Favicon image to upload your image file.In the next step, the webpage will show all usage scenarios. You can keep the default options, scroll to the bottom of the page, and click the button Generate your Favicons and HTML code to generate the favicon.Download &amp; ReplaceDownload the generated package, unzip and delete the following two from the extracted files:  browserconfig.xml  site.webmanifestAnd then copy the remaining image files (.PNG and .ICO) to cover the original files in the directory assets/img/favicons/ of your Jekyll site. If your Jekyll site doesn’t have this directory yet, just create one.The following table will help you understand the changes to the favicon files:            File(s)      From Online Tool      From Chirpy                  *.PNG      ✓      ✗              *.ICO      ✓      ✗        ✓ means keep, ✗ means delete.The next time you build the site, the favicon will be replaced with a customized edition."
  },
  
  {
    "title": "Getting Started",
    "url": "/posts/getting-started/",
    "categories": "Blogging, Tutorial",
    "tags": "getting started",
    "date": "2019-08-09 07:55:00 -0500",
    





    
    "snippet": "Creating a Site RepositoryWhen creating your site repository, you have two options depending on your needs:Option 1. Using the Starter (Recommended)This approach simplifies upgrades, isolates unnec...",
    "content": "Creating a Site RepositoryWhen creating your site repository, you have two options depending on your needs:Option 1. Using the Starter (Recommended)This approach simplifies upgrades, isolates unnecessary files, and is perfect for users who want to focus on writing with minimal configuration.  Sign in to GitHub and navigate to the starter.  Click the Use this template button and then select Create a new repository.  Name the new repository &lt;username&gt;.github.io, replacing username with your lowercase GitHub username.Option 2. Forking the ThemeThis approach is convenient for modifying features or UI design, but presents challenges during upgrades. So don’t try this unless you are familiar with Jekyll and plan to heavily modify this theme.  Sign in to GitHub.  Fork the theme repository.  Name the new repository &lt;username&gt;.github.io, replacing username with your lowercase GitHub username.Setting up the EnvironmentOnce your repository is created, it’s time to set up your development environment. There are two primary methods:Using Dev Containers (Recommended for Windows)Dev Containers offer an isolated environment using Docker, which prevents conflicts with your system and ensures all dependencies are managed within the container.Steps:  Install Docker:          On Windows/macOS, install Docker Desktop.      On Linux, install Docker Engine.        Install VS Code and the Dev Containers extension.  Clone your repository:          For Docker Desktop: Start VS Code and clone your repo in a container volume.      For Docker Engine: Clone your repo locally, then open it in a container via VS Code.        Wait for the Dev Containers setup to complete.Setting up Natively (Recommended for Unix-like OS)For Unix-like systems, you can set up the environment natively for optimal performance, though you can also use Dev Containers as an alternative.Steps:  Follow the Jekyll installation guide to install Jekyll and ensure Git is installed.  Clone your repository to your local machine.  If you forked the theme, install Node.js and run bash tools/init.sh in the root directory to initialize the repository.  Run command bundle in the root of your repository to install the dependencies.UsageStart the Jekyll ServerTo run the site locally, use the following command:$ bundle exec jekyll s  If you are using Dev Containers, you must run that command in the VS Code Terminal.After a few seconds, the local server will be available at http://127.0.0.1:4000.ConfigurationUpdate the variables in _config.yml as needed. Some typical options include:  url  avatar  timezone  langSocial Contact OptionsSocial contact options are displayed at the bottom of the sidebar. You can enable or disable specific contacts in the _data/contact.yml file.Customizing the StylesheetTo customize the stylesheet, copy the theme’s assets/css/jekyll-theme-chirpy.scss file to the same path in your Jekyll site, and add your custom styles at the end of the file.Starting with version 6.2.0, if you want to overwrite the SASS variables defined in _sass/addon/variables.scss, copy the main SASS file _sass/main.scss to the _sass directory in your site’s source, then create a new file _sass/variables-hook.scss and assign your new values there.Customizing Static AssetsStatic assets configuration was introduced in version 5.1.0. The CDN of the static assets is defined in _data/origin/cors.yml. You can replace some of them based on the network conditions in the region where your website is published.If you prefer to self-host the static assets, refer to the chirpy-static-assets repository.DeploymentBefore deploying, check the _config.yml file and ensure the url is configured correctly. If you prefer a project site and don’t use a custom domain, or if you want to visit your website with a base URL on a web server other than GitHub Pages, remember to set the baseurl to your project name, starting with a slash, e.g., /project-name.Now you can choose ONE of the following methods to deploy your Jekyll site.Deploy Using Github ActionsPrepare the following:  If you’re on the GitHub Free plan, keep your site repository public.      If you have committed Gemfile.lock to the repository, and your local machine is not running Linux, update the platform list of the lock file:    $ bundle lock --add-platform x86_64-linux      Next, configure the Pages service:      Go to your repository on GitHub. Select the Settings tab, then click Pages in the left navigation bar. In the Source section (under Build and deployment), select GitHub Actions from the dropdown menu.        Push any commits to GitHub to trigger the Actions workflow. In the Actions tab of your repository, you should see the workflow Build and Deploy running. Once the build is complete and successful, the site will be deployed automatically.  You can now visit the URL provided by GitHub to access your site.Manual Build and DeploymentFor self-hosted servers, you will need to build the site on your local machine and then upload the site files to the server.Navigate to the root of the source project, and build your site with the following command:$ JEKYLL_ENV=production bundle exec jekyll bUnless you specified the output path, the generated site files will be placed in the _site folder of the project’s root directory. Upload these files to your target server."
  },
  
  {
    "title": "Writing a New Post",
    "url": "/posts/write-a-new-post/",
    "categories": "Blogging, Tutorial",
    "tags": "writing",
    "date": "2019-08-08 01:10:00 -0500",
    





    
    "snippet": "This tutorial will guide you how to write a post in the Chirpy template, and it’s worth reading even if you’ve used Jekyll before, as many features require specific variables to be set.Naming and P...",
    "content": "This tutorial will guide you how to write a post in the Chirpy template, and it’s worth reading even if you’ve used Jekyll before, as many features require specific variables to be set.Naming and PathCreate a new file named YYYY-MM-DD-TITLE.EXTENSION and put it in the _posts of the root directory. Please note that the EXTENSION must be one of md and markdown. If you want to save time of creating files, please consider using the plugin Jekyll-Compose to accomplish this.Front MatterBasically, you need to fill the Front Matter as below at the top of the post:---title: TITLEdate: YYYY-MM-DD HH:MM:SS +/-TTTTcategories: [TOP_CATEGORIE, SUB_CATEGORIE]tags: [TAG]     # TAG names should always be lowercase---  The posts’ layout has been set to post by default, so there is no need to add the variable layout in the Front Matter block.Timezone of DateTo accurately record the release date of a post, you should not only set up the timezone of _config.yml but also provide the post’s timezone in variable date of its Front Matter block. Format: +/-TTTT, e.g. +0800.Categories and TagsThe categories of each post are designed to contain up to two elements, and the number of elements in tags can be zero to infinity. For instance:---categories: [Animal, Insect]tags: [bee]---Author InformationThe author information of the post usually does not need to be filled in the Front Matter , they will be obtained from variables social.name and the first entry of social.links of the configuration file by default. But you can also override it as follows:Adding author information in _data/authors.yml (If your website doesn’t have this file, don’t hesitate to create one).&lt;author_id&gt;:  name: &lt;full name&gt;  twitter: &lt;twitter_of_author&gt;  url: &lt;homepage_of_author&gt;And then use author to specify a single entry or authors to specify multiple entries:---author: &lt;author_id&gt;                     # for single entry# orauthors: [&lt;author1_id&gt;, &lt;author2_id&gt;]   # for multiple entries---Having said that, the key author can also identify multiple entries.  The benefit of reading the author information from the file _data/authors.yml is that the page will have the meta tag twitter:creator, which enriches the Twitter Cards and is good for SEO.Post DescriptionBy default, the first words of the post are used to display on the home page for a list of posts, in the Further Reading section, and in the XML of the RSS feed. If you don’t want to display the auto-generated description for the post, you can customize it using the description field in the Front Matter as follows:---description: Short summary of the post.---Additionally, the description text will also be displayed under the post title on the post’s page.Table of ContentsBy default, the Table of Contents (TOC) is displayed on the right panel of the post. If you want to turn it off globally, go to _config.yml and set the value of variable toc to false. If you want to turn off TOC for a specific post, add the following to the post’s Front Matter:---toc: false---CommentsThe global switch of comments is defined by variable comments.active in the file _config.yml. After selecting a comment system for this variable, comments will be turned on for all posts.If you want to close the comment for a specific post, add the following to the Front Matter of the post:---comments: false---MediaWe refer to images, audio and video as media resources in Chirpy.URL PrefixFrom time to time we have to define duplicate URL prefixes for multiple resources in a post, which is a boring task that you can avoid by setting two parameters.      If you are using a CDN to host media files, you can specify the cdn in _config.yml. The URLs of media resources for site avatar and posts are then prefixed with the CDN domain name.    cdn: https://cdn.com            To specify the resource path prefix for the current post/page range, set media_subpath in the front matter of the post:    ---media_subpath: /path/to/media/---      The option site.cdn and page.media_subpath can be used individually or in combination to flexibly compose the final resource URL: [site.cdn/][page.media_subpath/]file.extImagesCaptionAdd italics to the next line of an image, then it will become the caption and appear at the bottom of the image:![img-description](/path/to/image)_Image Caption_SizeTo prevent the page content layout from shifting when the image is loaded, we should set the width and height for each image.![Desktop View](/assets/img/sample/mockup.png){: width=\"700\" height=\"400\" }  For an SVG, you have to at least specify its width, otherwise it won’t be rendered.Starting from Chirpy v5.0.0, height and width support abbreviations (height → h, width → w). The following example has the same effect as the above:![Desktop View](/assets/img/sample/mockup.png){: w=\"700\" h=\"400\" }PositionBy default, the image is centered, but you can specify the position by using one of the classes normal, left, and right.  Once the position is specified, the image caption should not be added.      Normal position    Image will be left aligned in below sample:    ![Desktop View](/assets/img/sample/mockup.png){: .normal }            Float to the left    ![Desktop View](/assets/img/sample/mockup.png){: .left }            Float to the right    ![Desktop View](/assets/img/sample/mockup.png){: .right }      Dark/Light modeYou can make images follow theme preferences in dark/light mode. This requires you to prepare two images, one for dark mode and one for light mode, and then assign them a specific class (dark or light):![Light mode only](/path/to/light-mode.png){: .light }![Dark mode only](/path/to/dark-mode.png){: .dark }ShadowThe screenshots of the program window can be considered to show the shadow effect:![Desktop View](/assets/img/sample/mockup.png){: .shadow }Preview ImageIf you want to add an image at the top of the post, please provide an image with a resolution of 1200 x 630. Please note that if the image aspect ratio does not meet 1.91 : 1, the image will be scaled and cropped.Knowing these prerequisites, you can start setting the image’s attribute:---image:  path: /path/to/image  alt: image alternative text---Note that the media_subpath can also be passed to the preview image, that is, when it has been set, the attribute path only needs the image file name.For simple use, you can also just use image to define the path.---image: /path/to/image---LQIPFor preview images:---image:  lqip: /path/to/lqip-file # or base64 URI---  You can observe LQIP in the preview image of post \"Text and Typography\".For normal images:![Image description](/path/to/image){: lqip=\"/path/to/lqip-file\" }VideoSocial Media PlatformYou can embed videos from social media platforms with the following syntax:{% include embed/{Platform}.html id='{ID}' %}Where Platform is the lowercase of the platform name, and ID is the video ID.The following table shows how to get the two parameters we need in a given video URL, and you can also know the currently supported video platforms.            Video URL      Platform      ID                  https://www.youtube.com/watch?v=H-B46URT4mg      youtube      H-B46URT4mg              https://www.twitch.tv/videos/1634779211      twitch      1634779211              https://www.bilibili.com/video/BV1Q44y1B7Wf      bilibili      BV1Q44y1B7Wf      Video FilesIf you want to embed a video file directly, use the following syntax:{% include embed/video.html src='{URL}' %}Where URL is a URL to a video file e.g. /path/to/sample/video.mp4.You can also specify additional attributes for the embedded video file. Here is a full list of attributes allowed.  poster='/path/to/poster.png' — poster image for a video that is shown while video is downloading  title='Text' — title for a video that appears below the video and looks same as for images  autoplay=true — video automatically begins to play back as soon as it can  loop=true — automatically seek back to the start upon reaching the end of the video  muted=true — audio will be initially silenced  types — specify the extensions of additional video formats separated by |. Ensure these files exist in the same directory as your primary video file.Consider an example using all of the above:{%  include embed/video.html  src='/path/to/video.mp4'  types='ogg|mov'  poster='poster.png'  title='Demo video'  autoplay=true  loop=true  muted=true%}AudiosIf you want to embed an audio file directly, use the following syntax:{% include embed/audio.html src='{URL}' %}Where URL is a URL to an audio file e.g. /path/to/audio.mp3.You can also specify additional attributes for the embedded audio file. Here is a full list of attributes allowed.  title='Text' — title for an audio that appears below the audio and looks same as for images  types — specify the extensions of additional audio formats separated by |. Ensure these files exist in the same directory as your primary audio file.Consider an example using all of the above:{%  include embed/audio.html  src='/path/to/audio.mp3'  types='ogg|wav|aac'  title='Demo audio'%}Pinned PostsYou can pin one or more posts to the top of the home page, and the fixed posts are sorted in reverse order according to their release date. Enable by:---pin: true---PromptsThere are several types of prompts: tip, info, warning, and danger. They can be generated by adding the class prompt-{type} to the blockquote. For example, define a prompt of type info as follows:&gt; Example line for prompt.{: .prompt-info }SyntaxInline Code`inline code part`Filepath Highlight`/path/to/a/file.extend`{: .filepath}Code BlockMarkdown symbols ``` can easily create a code block as follows:```This is a plaintext code snippet.```Specifying LanguageUsing ```{language} you will get a code block with syntax highlight:```yamlkey: value```  The Jekyll tag {% highlight %} is not compatible with this theme.Line NumberBy default, all languages except plaintext, console, and terminal will display line numbers. When you want to hide the line number of a code block, add the class nolineno to it:```shellecho 'No more line numbers!'```{: .nolineno }Specifying the FilenameYou may have noticed that the code language will be displayed at the top of the code block. If you want to replace it with the file name, you can add the attribute file to achieve this:```shell# content```{: file=\"path/to/file\" }Liquid CodesIf you want to display the Liquid snippet, surround the liquid code with {% raw %} and {% endraw %}:{% raw %}```liquid{% if product.title contains 'Pack' %}  This product's title contains the word Pack.{% endif %}```{% endraw %}Or adding render_with_liquid: false (Requires Jekyll 4.0 or higher) to the post’s YAML block.MathematicsWe use MathJax to generate mathematics. For website performance reasons, the mathematical feature won’t be loaded by default. But it can be enabled by:---math: true---After enabling the mathematical feature, you can add math equations with the following syntax:  Block math should be added with $$ math $$ with mandatory blank lines before and after $$          Inserting equation numbering should be added with $$\\begin{equation} math \\end{equation}$$      Referencing equation numbering should be done with \\label{eq:label_name} in the equation block and \\eqref{eq:label_name} inline with text (see example below)        Inline math (in lines) should be added with $$ math $$ without any blank line before or after $$  Inline math (in lists) should be added with \\$$ math $$&lt;!-- Block math, keep all blank lines --&gt;$$LaTeX_math_expression$$&lt;!-- Equation numbering, keep all blank lines  --&gt;$$\\begin{equation}  LaTeX_math_expression  \\label{eq:label_name}\\end{equation}$$Can be referenced as \\eqref{eq:label_name}.&lt;!-- Inline math in lines, NO blank lines --&gt;\"Lorem ipsum dolor sit amet, $$ LaTeX_math_expression $$ consectetur adipiscing elit.\"&lt;!-- Inline math in lists, escape the first `$` --&gt;1. \\$$ LaTeX_math_expression $$2. \\$$ LaTeX_math_expression $$3. \\$$ LaTeX_math_expression $$  Starting with v7.0.0, configuration options for MathJax have been moved to file assets/js/data/mathjax.js, and you can change the options as needed, such as adding extensions.If you are building the site via chirpy-starter, copy that file from the gem installation directory (check with command bundle info --path jekyll-theme-chirpy) to the same directory in your repository.MermaidMermaid is a great diagram generation tool. To enable it on your post, add the following to the YAML block:---mermaid: true---Then you can use it like other markdown languages: surround the graph code with ```mermaid and ```.Learn MoreFor more knowledge about Jekyll posts, visit the Jekyll Docs: Posts."
  }
  
]

